<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Decode Effect</title>
		<style>
			/* A monospace font is crucial for this effect */
			/* It ensures all characters have the same width, */
			/* preventing the text from jumping around. */
			body {
				background-color: #111;
				color: #0f0;
				font-family: 'Courier New', Courier, monospace;
				display: grid;
				place-items: center;
				min-height: 100vh;
				font-size: 2rem;
				text-align: center; /* Added for better mobile wrapping */
				padding: 1rem; /* Added for mobile */
			}

			h1 {
				word-break: break-all; /* Allow text to wrap if it's too long */
			}
		</style>
	</head>
	<body>
		<h1 id="decode-text">HELLO WORLD. THIS IS A DECODING EFFECT.</h1>

		<script>
			/**
			 * A performant and readable class for creating a "decode" text effect.
			 * It uses requestAnimationFrame and time-based intervals for smoothness.
			 */
			class TextDecoder {
				// Characters to use for scrambling
				static SCRAMBLE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+=[]{}|;:,.<>?';

				constructor(element) {
					this.el = element;
					this.targetText = element.textContent;

					// Store the current state of the text as an array
					this.currentText = this.targetText.split('');

					// Animation loop and timing state
					this.animationFrameId = null;
					this.lastRevealTime = 0;
					this.lastScrambleTime = 0;

					// How many characters from the start are "locked in"
					this.revealProgress = 0;

					// Configurable speeds
					this.config = {
						revealSpeedMs: 50, // Time between revealing the next character
						scrambleSpeedMs: 30 // Time between re-scrambling the remaining chars
					};

					// Bind the 'this' context for the animation loop
					this.update = this.update.bind(this);
				}

				/**
				 * Returns a random character from the scramble set.
				 */
				getRandomChar() {
					const i = Math.floor(Math.random() * TextDecoder.SCRAMBLE_CHARS.length);
					return TextDecoder.SCRAMBLE_CHARS[i];
				}

				/**
				 * Starts the decoding animation.
				 */
				start() {
					// Reset state
					this.revealProgress = 0;
					const now = performance.now();
					this.lastRevealTime = now;
					this.lastScrambleTime = now;

					// Initialize all characters to random
					for (let i = 0; i < this.targetText.length; i++) {
						// Respect spaces in the original text
						if (this.targetText[i] === ' ') {
							this.currentText[i] = ' ';
						} else {
							this.currentText[i] = this.getRandomChar();
						}
					}

					// Stop any existing animation
					if (this.animationFrameId) {
						cancelAnimationFrame(this.animationFrameId);
					}

					// Start the new animation loop
					this.animationFrameId = requestAnimationFrame(this.update);
				}

				/**
				 * The main animation loop, called by requestAnimationFrame.
				 * @param {number} timestamp - The current high-resolution timestamp
				 */
				update(timestamp) {
					// 1. Check if the animation is complete
					if (this.revealProgress >= this.targetText.length) {
						this.el.textContent = this.targetText; // Final cleanup
						return; // Stop the loop
					}

					// 2. Handle Character "Reveal" Logic
					// Based on time, check if we should reveal the next character
					if (timestamp - this.lastRevealTime > this.config.revealSpeedMs) {
						this.lastRevealTime = timestamp;

						// Advance progress, but keep skipping spaces
						do {
							this.revealProgress++;
						} while (
							this.revealProgress < this.targetText.length &&
							this.targetText[this.revealProgress - 1] === ' '
						);
					}

					// 3. Handle "Scramble" Logic
					// Based on time, check if we should re-randomize the unscrambled part
					if (timestamp - this.lastScrambleTime > this.config.scrambleSpeedMs) {
						this.lastScrambleTime = timestamp;

						// Scramble all characters *after* the reveal progress index
						for (let i = this.revealProgress; i < this.targetText.length; i++) {
							// Don't scramble spaces
							if (this.targetText[i] === ' ') {
								this.currentText[i] = ' ';
							} else {
								this.currentText[i] = this.getRandomChar();
							}
						}
					}

					// 4. Build and Render the Output String
					// We do this every frame to show the latest state.
					let output = '';
					for (let i = 0; i < this.targetText.length; i++) {
						if (i < this.revealProgress) {
							// Use the correct, "locked-in" character
							output += this.targetText[i];
						} else {
							// Use the currently scrambled character
							output += this.currentText[i];
						}
					}
					this.el.textContent = output;

					// 5. Continue the loop
					this.animationFrameId = requestAnimationFrame(this.update);
				}
			}

			// --- Initialization ---
			document.addEventListener('DOMContentLoaded', () => {
				const el = document.getElementById('decode-text');
				const decoder = new TextDecoder(el);

				// Start the effect
				decoder.start();

				// Optional: Restart effect on click for demonstration
				// --- This was the line with the syntax error ---
				// It was `(). =>` but should be `() =>`
				el.addEventListener('click', () => decoder.start());
			});
		</script>
	</body>
</html>
