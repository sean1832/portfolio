<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Euclidean Grid Distortion Prototype</title>
		<style>
			:root {
				--bg-color: #ffffff; /* White */
				--grid-color: #000000; /* Black */
			}
			body {
				margin: 0;
				padding: 0;
				overflow: hidden;
				background-color: var(--bg-color);
				font-family: 'Inter', system-ui, sans-serif;
			}
			canvas {
				display: block;
			}
			.overlay {
				position: absolute;
				bottom: 2rem;
				left: 2rem;
				color: var(--grid-color);
				pointer-events: none;
				font-size: 0.8rem;
				letter-spacing: 0.05em;
				font-weight: 500;
			}
		</style>
	</head>
	<body>
		<canvas id="gridCanvas"></canvas>

		<div class="overlay">
			<div>ZEN_GRID // MINIMAL</div>
			<div id="stats">ENTITIES: 0 | FPS: 0</div>
		</div>

		<script>
			/**
			 * EUCLIDEAN GRID DISTORTION (ZEN MODE)
			 * * Minimalist point-based grid system.
			 */

			// --- Configuration ---
			const CONFIG = {
				gridSpacing: 45, // Slightly wider spacing for "zen" feel
				pointSize: 3.5, // Diameter of the dot
				mouseRadius: 200, // Larger interaction radius
				mouseForce: 200, // Slightly softer force
				springStiffness: 0.01, // Softer springs
				springDamping: 0.9, // Higher damping for fluid, viscous movement
				color: '#000000' // Black dots
			};

			// --- State ---
			const canvas = document.getElementById('gridCanvas');
			const ctx = canvas.getContext('2d', { alpha: false }); // Alpha false optimization
			const statsEl = document.getElementById('stats');

			// Physics State (SoA/AoS hybrid in a single buffer for cache locality)
			// Stride = 4: [currentX, currentY, velocityX, velocityY]
			let physicsData = new Float32Array(0);
			let cols = 0;
			let rows = 0;
			let numPoints = 0;

			// Interaction State
			const mouse = { x: -1000, y: -1000 };
			let width = 0;
			let height = 0;
			let lastTime = 0;
			let frameCount = 0;

			/**
			 * Initialize the grid system based on viewport dimensions.
			 */
			function resize() {
				width = window.innerWidth;
				height = window.innerHeight;
				canvas.width = width;
				canvas.height = height;

				cols = Math.ceil(width / CONFIG.gridSpacing) + 1;
				rows = Math.ceil(height / CONFIG.gridSpacing) + 1;
				numPoints = cols * rows;

				// Re-allocate buffer if necessary
				const requiredSize = numPoints * 4;
				if (physicsData.length < requiredSize) {
					physicsData = new Float32Array(requiredSize);
				}

				// Initialize positions
				for (let i = 0; i < numPoints; i++) {
					const col = i % cols;
					const row = Math.floor(i / cols);
					const baseX = col * CONFIG.gridSpacing;
					const baseY = row * CONFIG.gridSpacing;

					const idx = i * 4;
					physicsData[idx] = baseX; // x
					physicsData[idx + 1] = baseY; // y
					physicsData[idx + 2] = 0; // vx
					physicsData[idx + 3] = 0; // vy
				}

				console.log(`[System] Grid resized: ${cols}x${rows} (${numPoints} entities)`);
			}

			/**
			 * Physics Update Loop
			 */
			function updatePhysics() {
				const { gridSpacing, mouseRadius, mouseForce, springStiffness, springDamping } = CONFIG;
				const radiusSq = mouseRadius * mouseRadius;

				for (let i = 0; i < numPoints; i++) {
					const idx = i * 4;

					// 1. Get Current State
					const x = physicsData[idx];
					const y = physicsData[idx + 1];
					let vx = physicsData[idx + 2];
					let vy = physicsData[idx + 3];

					// 2. Calculate Target (Base) Position
					const col = i % cols;
					const row = Math.floor(i / cols);
					const targetX = col * gridSpacing;
					const targetY = row * gridSpacing;

					// 3. Apply Mouse Repulsion
					const dx = x - mouse.x;
					const dy = y - mouse.y;
					const distSq = dx * dx + dy * dy;

					if (distSq < radiusSq) {
						const dist = Math.sqrt(distSq);
						if (dist > 0) {
							const f = (1 - dist / mouseRadius) * mouseForce;
							vx += (dx / dist) * f * 0.01;
							vy += (dy / dist) * f * 0.01;
						}
					}

					// 4. Apply Spring Force
					const ex = x - targetX;
					const ey = y - targetY;

					vx -= ex * springStiffness;
					vy -= ey * springStiffness;

					// 5. Apply Damping
					vx *= springDamping;
					vy *= springDamping;

					// 6. Integration
					physicsData[idx] = x + vx;
					physicsData[idx + 1] = y + vy;
					physicsData[idx + 2] = vx;
					physicsData[idx + 3] = vy;
				}
			}

			/**
			 * Render Loop
			 */
			function render() {
				// Clear background to white
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(0, 0, width, height);

				ctx.fillStyle = CONFIG.color;
				const radius = CONFIG.pointSize / 2;

				// Batch drawing path for performance
				ctx.beginPath();

				for (let i = 0; i < numPoints; i++) {
					const idx = i * 4;
					const x = physicsData[idx];
					const y = physicsData[idx + 1];

					// Draw Circle (Dot)
					// Must moveTo to avoid connecting lines between arcs
					ctx.moveTo(x + radius, y);
					ctx.arc(x, y, radius, 0, Math.PI * 2);
				}

				ctx.fill();
			}

			/**
			 * Main Animation Loop
			 */
			function loop(timestamp) {
				if (timestamp - lastTime >= 1000) {
					statsEl.innerText = `ENTITIES: ${numPoints} | FPS: ${frameCount}`;
					frameCount = 0;
					lastTime = timestamp;
				}
				frameCount++;

				updatePhysics();
				render();
				requestAnimationFrame(loop);
			}

			// --- Event Listeners ---
			window.addEventListener('resize', () => resize());
			window.addEventListener('mousemove', (e) => {
				mouse.x = e.clientX;
				mouse.y = e.clientY;
			});
			window.addEventListener(
				'touchmove',
				(e) => {
					if (e.touches.length > 0) {
						mouse.x = e.touches[0].clientX;
						mouse.y = e.touches[0].clientY;
					}
				},
				{ passive: true }
			);
			window.addEventListener(
				'touchstart',
				(e) => {
					if (e.touches.length > 0) {
						mouse.x = e.touches[0].clientX;
						mouse.y = e.touches[0].clientY;
					}
				},
				{ passive: true }
			);
			window.addEventListener('touchend', () => {
				mouse.x = -1000;
				mouse.y = -1000;
			});

			// --- Boot ---
			resize();
			requestAnimationFrame(loop);
		</script>
	</body>
</html>
